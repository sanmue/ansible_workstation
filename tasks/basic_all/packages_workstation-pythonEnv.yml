# ######################
# ### Python Environment
# ######################

# pyenv ist bereits installiert über Paketmanager (Arch: ...workstation-basic.yml) bzw. InstalScript+localPackageIntstall.yml (Debian)
# + siehe ...localPackageInstall.yml # + ...all-settings-misc.yml (shell config)

# !!!
# - pyenv:
#   - https://technicalnavigator.in/how-to-fix-error-externally-managed-environment-in-python-kali-linux/
#
# - allgemein:
# - https://stackoverflow.com/questions/75608323/how-do-i-solve-error-externally-managed-environment-everytime-i-use-pip3
# - https://stackoverflow.com/questions/75602063/pip-install-r-requirements-txt-is-failing-this-environment-is-externally-manag/75696359#75696359
# - https://packaging.python.org/en/latest/specifications/externally-managed-environments/#writing-to-only-the-target-sysconfig-scheme
# !!!

# Zusammenfassung der ermittelten Python Version:
- name: Python Environment - Get and register Python version (all)
  become: true
  become_user: "{{ env_user }}"
  ansible.builtin.shell: |
    set -o pipefail
    {{ python_cmd }} --version 2>&1 | cut -d ' ' -f2
    # 2>&1: Leitet stderr nach stdout um, falls python --version auf stderr schreibt
  register: python_version
  args:
    executable: /bin/bash # Erzwingt die Verwendung von Bash (Sicherstellung einer Shell mit Unterstütztung von pipefail)
    creates: "/home/{{ env_user }}/.ansible_PythonEnv"
  vars:
    python_cmd: "{% if ansible_facts['distribution'] == 'Archlinux' %}python{% else %}python3{% endif %}"
  # ignore_errors: true
  failed_when:
    - python_version.rc != 0
    - python_version.stdout == ""
    # verhindert, dass Task bei "normalen" Fehlern (z. B. Python nicht installiert) sofort abbricht,
    # aber trotzdem als fehlgeschlagen markiert wird, wenn wirklich etwas schiefgeht (z. B. Kommando nicht ausführbar)
  changed_when: false # Da der Task nur Informationen abfragt, sollte er nicht als "changed" markiert werden.

# - name: Python Environment - msg python_version (env_user, all)
#   become: true
#   become_user: "{{ env_user }}"
#   ansible.builtin.debug:
#     var: python_version
#     # var: python_version.stdout

- name: Python Environment - pyenv install python (env_user, all)
  become: true
  become_user: "{{ env_user }}"
  ansible.builtin.shell: "pyenv install {{ python_version.stdout }}"
  args:
    creates: "/home/{{ env_user }}/.pyenv/versions/{{ python_version.stdout }}"
  register: pyenv_install_result
  changed_when: pyenv_install_result.rc == 0 # Markiert den Task nur als "changed", wenn der Befehl erfolgreich war (Return Code 0)
  failed_when: # Definiert, wann der Task als fehlgeschlagen gilt
    - pyenv_install_result.rc != 0
    - "'already installed' not in pyenv_install_result.stderr"
    - "'definition not found' not in pyenv_install_result.stderr"
    # d.h.: Ignoriere den Fehler, wenn die Version bereits installiert ist oder wenn die Version nicht gefunden wird

- name: Python Environment - pyenv set global python version (env_user, all)
  become: true
  become_user: "{{ env_user }}"
  ansible.builtin.shell: "pyenv global {{ python_version.stdout }}"
  args:
    creates: "/home/{{ env_user }}/.ansible_PythonEnv"

- name: Python Environment - set flag file for Python Environment (env_user, all)
  become: true
  become_user: "{{ env_user }}"
  ansible.builtin.file:
    path: "/home/{{ env_user }}/.ansible_PythonEnv"
    state: touch
    mode: u=rw,g=r,o=r
    modification_time: preserve
    access_time: preserve

# https://github.com/pyenv/pyenv-virtualenv?tab=readme-ov-file#installing-as-a-pyenv-plugin
- name: Python Environment - pyenv - install pyenv-virtualenv as pyenv plugin
  become: true
  become_user: "{{ env_user }}"
  ansible.builtin.git:
    repo: https://github.com/pyenv/pyenv-virtualenv.git
    dest: "/home/{{ env_user }}/.pyenv/plugins/pyenv-virtualenv" # $(pyenv root)/plugins/pyenv-virtualenv
    clone: true
    update: true
