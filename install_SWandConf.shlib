#!/usr/bin/env bash
# shellcheck disable=SC2154

# set -x   # enable debug mode

config-zram() {
    echo "Installing 'zram-generator'..."
    sudo pacman -S --needed --noconfirm zram-generator
    echo "Creating zram-generator config..."
    # zramGeneratorConfFilePath="/etc/systemd/zram-generator.conf" # wird gesetzt in 'install_SWandConf.sh'
    # zramSize=2 # e.g.: 2 -> 1/2 = 50 % of RAM size # wird gesetzt in 'install_SWandConf.sh'
    sudo touch "${zramGeneratorConfFilePath}"
    echo -e "[zram0]\nzram-size = ram / ${zramSize}\ncompression-algorithm = zstd" | sudo tee "${zramGeneratorConfFilePath}" >/dev/null
    echo "Reloading daemon and starting systemd-zram-setup service for zram..."
    sudo systemctl daemon-reload
    sudo systemctl start systemd-zram-setup@zram0.service # zram'0': -> assuming its the only / first zram
    echo "Check:"
    # sudo zramctl --output-all # Check # swapon -s # or: zramctl --output-all # or: cat /proc/swaps # or: systemctl status systemd-zram-setup@zram0.service
    sudo zramctl --output-all && echo "" && swapon --output-all
    echo -e "\nOptimization settings for swap on zram..."
    # zramParameterConfFilePath="/etc/sysctl.d/99-vm-zram-parameters.conf" # wird gesetzt in 'install_SWandConf.sh'
    sudo touch "${zramParameterConfFilePath}"
    echo -e "vm.swappiness = 180\nvm.watermark_boost_factor = 0" | sudo tee "${zramParameterConfFilePath}" >/dev/null
    echo -e "vm.watermark_scale_factor = 125\nvm.page-cluster = 0" | sudo tee --append "${zramParameterConfFilePath}" >/dev/null
}

config-snapper() {
    # --- START check fstab + set file system name ----------------------------
    # Script only works if btrfs subvolumes are already created (e.g. recommended subvolume layout, with subvolumes: '@', '@home', ...)
    # therefore checking fstab: - for btrfs root subvolume '@/'
    #                           - '<file system>' part will be used later for creating new fstab entries for subvolumes (see further below)

    fstabEntryBtrfsRootSubvol=$(grep -e "subvol=/@[^a-zA-Z]" /etc/fstab) # btrfs subvolumes already created + mounted (+ encryption)
    # e.g.: "/dev/mapper/luks-7bee452d-... / btrfs subvol=/@,defaults,... 0 0" or: "UUID=luks-8f1cf7bc-8064-...   / btrfs subvol=/@,defaults,... 0 0"

    # if the above grep did not return a match, its perhaps because of no (recommended) btrfs subvolume layout has been created (-> e.g. no subvolumes: '@', '@home', ...):
    if [ -z "${fstabEntryBtrfsRootSubvol}" ]; then # "default" btrfs root '/' without (recommended) subvolumes: "initial" entry still in fstab
        echo "Aktuelle /etc/fstab:"
        cat /etc/fstab

        # --- START #TODO: aktuell nicht implementiert
        # fstabFileSystem=$(grep -w "subvol=/" /etc/fstab | cut -f 1 | xargs)           # e.g.: "UUID=8a6bb50a-11d3-4aff-bba9-e7234a9228c5 / btrfs rw,noatime,...,subvolid=5,subvol=/ 0 0"
        #       - can occur: standard install with btrfs, but without specifying (recommended) subvolume layout # '...subvolid=5,subvol=/...' is default entry for btrfs root subvolume
        # --- ENDE aktuell nicht implementiert
        deleteOldRootInFstab="true" # marker, that this fstab entry has to be erased (or we will have 2 entries for '/' in fstab later)

        echo -e "\e[0;31mEs muss schon ein btrfs subvolume layout vorhanden sein, damit dieses Script funkiontiert.\e[0m"
        echo -e "\e[0;31mManuelle Durchführung erforderlich. Sorry, Ende.\e[0m"
        exit 1
    fi

    case "${fstabEntryBtrfsRootSubvol}" in
        /dev*)
            # /dev/mapper/luks-cc2e4215-6edc-41c8-9b03-d478bee0a61c / btrfs subvol=/@,defaults,noatime,compress=zstd 0 0'
            # e.g. EndeavourOS + luks encryption
            fstabFileSystem=$(echo "${fstabEntryBtrfsRootSubvol}" | cut -d ' ' -f 1 | xargs) # /dev/mapper/luks-cc2e4215-6edc-41c8-9b03-d478bee0a61c
            ;;

        UUID*)
                                                                                    # UUID=luks-8f1cf7bc-8064-...   / btrfs subvol=/@,defaults,... 0 0
            fstabFileSystem=$(echo "${fstabEntryBtrfsRootSubvol}" | cut -f 1 | xargs) # UUID=luks-8f1cf7bc-8064-...
            if [ -z "${fstabFileSystem}" ]; then fstabFileSystem=$(echo "${fstabEntryBtrfsRootSubvol}" | cut -d ' ' -f 1 | xargs); fi
            ;;

        *)
            fstabFileSystem=$(echo "${fstabEntryBtrfsRootSubvol}" | cut -d ' ' -f 1 | xargs)
            echo -e "\e[0;31mDefault case 'fstabEntryBtrfsRootSubvol': fstab file system name could not be defined clearly.\e[0m"
            ;;
    esac

    echo -e "\e[0;33mSetting fstab file system name to\e[39m '${fstabFileSystem}' \e[0;33mfor now.\nYou can correct this later manually when prompted for confirmation.\e[0m"
    # --- END check fstab + set file system name ------------------------------

    if [ ! -e "${snapperSnapshotFolder}" ]; then # check if ${snapperSnapshotFolder} exists
        echo -e "\e[0;33m- Verzeichnis '${snapperSnapshotFolder}' nicht vorhanden. Evlt. abweichendes Verzeichnis konfiguriert?!\n- Ggf. vorheriger manueller Eingriff erforderlich.\e[0m"
        echo "Current btrfs subvolume list:"
        sudo btrfs subvolume list /
        read -r -p "Installation/Konfiguration fortsetzen? (beliebige Eingabe = ja, 'n' = nein): " continueScript
        if [ "${continueScript}" = "n" ]; then
            echo "Stopping Script"
            exit 0
        fi
    fi

    echo -e "\n\e[0;33m*** ********************************************\e[0m"
    echo -e "\e[0;33m*** Start: Installation und config von 'snapper'\e[0m"
    case "${os}" in
        Arch* | Endeavour*) # aktuell für UEFI oder BIOS jeweils mit GRUB-Bootloader (TODO: sowie für UEFI + systemd boot -> not (re-)tested)
            # https://wiki.archlinux.org/title/Btrfs
            # https://wiki.archlinux.org/title/Snapper
            # https://documentation.suse.com/sles/15-SP4/html/SLES-all/cha-snapper.html

            # ### ----------------------------
            # ### installing required software
            # ### ----------------------------
            echo -e "\n*** Installation of software packages needed for snapper..."
            sudo pacman --needed --noconfirm -S snapper snap-pac inotify-tools # snap-sync

            # Booting into (readonly) snapshots not used/needed anymore; using 'snapper list' + 'snapper-rollback'
            # if [ -e "${efiDir}/grub.cfg" ] || [ -e "/boot/grub" ]; then # GRUB (UEFI oder BIOS)
            #     sudo pacman --needed --noconfirm -S grub-btrfs # makes entries to grub for snapshots to be able to boot into them
            # fi

            echo -e "\n*** Installation of 'snapper-rollback' from AUR..."
            paru -S --needed --skipreview snapper-rollback

            # ### --------------
            # ### config snapper
            # ### --------------
            echo -e "\n*** (Re)create snapshots folder + snapper config..."
            # Arch Linux | EndeavourOS:
            # - '/.snapshots' wird nicht standardmäßig erstellt
            #
            # Info: beim erstellen der config ${snapperConfigName_root} wird automatisch ein Subvolume (und damit Verzeichnis) '.snapshots' auf '/' erstellt
            # welches wieder gelöscht wird, da das Subvolume für Snapshots '@snapshots' heißen soll
            #
            if [ -e "${snapperSnapshotFolder}" ]; then # falls bereits vorhanden
                echo "Unmount + Löschen '${snapperSnapshotFolder}', um angepasste Konfiguration durchzuführen..."
                sudo umount "${snapperSnapshotFolder}"
                sudo rm -rf "${snapperSnapshotFolder}" # entspricht löschen subvolume
            fi

            echo "*** Erstelle snapper config '${snapperConfigName_root}' für '/'"
            sudo snapper -c "${snapperConfigName_root}" create-config /

            echo "*** Lösche autom. angelegtes Subvolume '${snapperSnapshotFolder}' (aus vorherigem Schritt 'Erstelle snapper config')..."
            sudo btrfs subvolume delete "${snapperSnapshotFolder}"
            echo "*** Erstelle (wieder) Verzeichnis '${snapperSnapshotFolder}'..."
            sudo sudo mkdir -p "${snapperSnapshotFolder}"

            # ### ----------------
            # ### Btrfs subvolumes
            # ### ----------------
            echo "*** Erstelle Subvolumes (sofern nicht schon vorhanden) und entsprechende fstab-Einträge"

            # --- fstab
            echo "Aktuelle /etc/fstab:"
            cat /etc/fstab

            read -r -p "Nutze file system '${fstabFileSystem}'. Ist das korrekt ? ('n'=nein, sonstige Eingabe=ja): " fsok
            if [ "${fsok}" = "n" ]; then
                endloop='no'
                while [ ! "$endloop" = 'j' ]; do
                    read -r -p "Manuelle Eingabe: " fstabFileSystem
                    read -r -p "Ist '${fstabFileSystem}' korrekt ? ('j'=ja, beliebige Eingabe für Korrektur): " endloop
                done
            fi

            sudo cp /etc/fstab /etc/fstab.bak # Sicherung fstab

            # --- Mount btrfsroot
            echo -e "\nMount: 'subvolid=5' '${fstabFileSystem}' nach '/mnt'..."
            sudo mount -t btrfs -o subvolid=5 "$fstabFileSystem" /mnt # bzw. sudo mount -t btrfs -o "$btrfsFstabMountOptions_standard" /dev/vda3 /mnt

            # --- Create btrfs subvolumes
            for subvol in "${!btrfsSubvolLayout[@]}"; do
                if [ ! -e "/mnt/${subvol}" ]; then # wenn Subvolume noch nicht vorhanden
                    echo "|__ Erstelle Subvolume '/mnt/${subvol}'..."
                    sudo btrfs subvolume create "/mnt/${subvol}"
                else
                    echo -e "\e[0;33m|__ Subvolume '/mnt/${subvol}' bereits vorhanden\e[0m"
                fi
            done

            # --- Unmount btrfsroot
            echo -e "\nUnmount '/mnt'..."
            sudo umount /mnt

            # ### -----------------------
            # ### snapper-rollback folder
            # ### -----------------------
            echo -e "\nsnapper-rollback"
            if [ ! -d "/${snapperRollbackFolderName}" ]; then
                echo "|__ Erstelle snapperRollbackFolder '/${snapperRollbackFolderName}'..."
                sudo mkdir "/${snapperRollbackFolderName}" # e.g.: /.btrfsroot
            else
                echo -e "\e[0;33m|__ snapperRollbackFolder '/${snapperRollbackFolderName}' bereits vorhanden\e[0m"
            fi

            # ### -----
            # ### fstab
            # ### -----
            echo -e "\n*** Erstelle Einträge in '/etc/fstab':"

            # --- subvolumes
            for subvol in "${!btrfsSubvolLayout[@]}"; do
                subvolInFstab='false'
                mountPointInFstab='false'

                echo "|__ erstelle Eintrag für Subvolume '${subvol}' mit mount point '${btrfsSubvolLayout[${subvol}]}'..."

                if [ ! -e "${btrfsSubvolLayout[${subvol}]}" ]; then # wenn Mount-Ziel (Verzeichnis) noch nicht vorhanden
                    echo -e "\e[0;33m    |__ Mount-Ziel '${btrfsSubvolLayout[${subvol}]}' nicht vorhanden, Verzeichnis wird erstellt...\e[0m"
                    sudo mkdir -p "${btrfsSubvolLayout[${subvol}]}"
                fi

                if [[ $(grep "subvol=/${subvol}," /etc/fstab) ]]; then # wenn Eintrag für z.B. ...'subvol=/@,'... bereits vorhanden
                    echo -e "\e[0;33m    |__ Eintrag für Subvolume '${subvol}' bereits vorhanden, ggf. prüfen/korrigieren\e[0m"
                    subvolInFstab='true'
                fi

                if [[ $(grep -E " +${btrfsSubvolLayout[${subvol}]} +" /etc/fstab) ]]; then # wenn Mount Point (z.B. für '/') bereits vorhanden
                    echo -e "\e[0;33m    |__ Mount-Ziel '${btrfsSubvolLayout[${subvol}]}' bereits vorhanden, '${subvol}' wird nicht (nochmal) hinterlegt, ggf. prüfen/korrigieren\e[0m"
                    mountPointInFstab='true'
                fi

                if [ "${subvolInFstab}" = 'false' ] && [ "${mountPointInFstab}" = 'false' ]; then
                    echo "${fstabFileSystem} ${btrfsSubvolLayout[${subvol}]} btrfs subvol=/${subvol},${btrfsFstabMountOptions_standard}" | sudo tee -a /etc/fstab
                fi
            done

            if [ "${deleteOldRootInFstab}" = "true" ]; then
                sudo sed -i "/subvolid=5,subvol=\//d" /etc/fstab # delete the line containing 'subvolid=5,subvol=/'
            fi

            # --- snapperRollbackFolder (.btrfsroot)
            if [[ ! $(grep "/${snapperRollbackFolderName}" /etc/fstab) ]]; then
                echo "${fstabFileSystem} /${snapperRollbackFolderName} btrfs subvol=/,${btrfsFstabMountOptions_standard}" | sudo tee -a /etc/fstab
            fi

            # --- mount options EndeavourOS
            if [[ "${os}" = "EndeavourOS" ]]; then
                echo -e "\nModifiziere mount options in '/etc/fstab':"
                echo -e "- ersetze ggf. btrfs mount options (Endeavour)'...${btrfsFstabMountOptions_endeavour}' mit '...${btrfsFstabMountOptions_standard}'"
                sudo sed -i "s|${btrfsFstabMountOptions_endeavour}|${btrfsFstabMountOptions_standard}|g" /etc/fstab
            fi

            # --- daemon reload + mount
            echo "Aktualisiere systemd units aus fstab + mount all..."
            sudo systemctl daemon-reload && sudo mount -a

            # --- default subvolume
            echo -e "\n*** Default-Subvolume festlegen"
            echo "aktuelles default-Subvolume für '/': $(sudo btrfs subvolume get-default /)"
            echo -e "Subvolume-Liste:\n$(sudo btrfs subvolume list /)"
            endloop='n'
            while [ ! "$endloop" = 'j' ]; do
                read -r -p "Bitte ID von @ eingeben: " idRootSubvol
                read -r -p "Ist ID '${idRootSubvol}' korrekt ('j'=ja, beliebige Eingabe für Korrektur)?: " endloop
            done
            sudo btrfs subvolume set-default "${idRootSubvol}" / &&
                echo "aktuelles root default-Subvolume: $(sudo btrfs subvolume get-default /)"

            # --- Bootlaoder config
            # UEFI+Grub / BIOS+Grub / UEFI+systemD
            echo -e "\n*** Re-Install grub + Update grub boot-Einträge"
            # https://wiki.archlinux.org/title/GRUB
            # if [ -e "/sys/firmware/efi/efivars" ]; then    # check if booted into UEFI mode and UEFI variables are accessible
            # if [ -e "${efiDir}" ] && [ -e "/boot/grub/grub.cfg" ]; then # UEFI + Grub
            if [ "$(sudo ls "${efiDir}")" ] && [ -e "/boot/grub/grub.cfg" ]; then # UEFI + Grub
                sudo grub-install --target=x86_64-efi --efi-directory="${efiDir}" --bootloader-id="${bootloaderId}" &&
                    sudo grub-mkconfig -o /boot/grub/grub.cfg &&
                    sudo grub-mkconfig
            elif [ -e "/boot/grub/grub.cfg" ]; then # BIOS + Grub
                lsblk
                endloop='n'
                while [ ! "$endloop" = 'j' ]; do
                    read -r -p "Eingabe device-Pfad für grub-install (z.B. '/dev/vda'): " devGrubInstallPath # nicht Partition (z.B. '/dev/vda1'), sondern Disk (z.B. '/dev/vda')
                    read -r -p "Ist '${devGrubInstallPath}' korrekt ('j'=ja, beliebige Eingabe für Korrektur)?: " endloop
                done
                # https://wiki.archlinux.org/title/GRUB#Installation_2
                # BIOS: grub-install --target=i386-pc /dev/sdX; where i386-pc is deliberately used regardless of your actual architecture, and /dev/sdX is the disk (not a partition) where GRUB is to be installed.
                sudo grub-install --target=i386-pc "${devGrubInstallPath}" && sudo grub-mkconfig -o /boot/grub/grub.cfg &&
                    sudo grub-mkconfig
            elif [ "$(sudo ls "${efiDir}/loader")" ]; then # UEFI + Systemd Boot
                echo -e "\e[0;33mUEFI + systemD boot, kein TODO\e[0m"
            else
                echo "--- Bootloader nicht erkennbar ---"
                # systemd boot: kein Eintrag, manueller Sprung in tty (bzw. dracut macht neues img?)
            fi

            # --- snapper config
            echo -e "\n*** Snapper config '${snapperConfigName_root}' wird angepasst..." # /etc/snapper/configs/CONFIGS (z.B. /etc/snapper/configs/root)
            # sudo snapper -c "${snapperConfigName_root}" set-config "ALLOW_USERS=${userid}"
            sudo snapper -c "${snapperConfigName_root}" set-config "ALLOW_GROUPS=wheel"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_CREATE=no"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_LIMIT_HOURLY=5"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_LIMIT_DAILY=7"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_LIMIT_WEEKLY=0"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_LIMIT_MONTHLY=0"
            sudo snapper -c "${snapperConfigName_root}" set-config "TIMELINE_LIMIT_YEARLY=0"

            # --- snapper-rollback config
            config-snapperRollback "/${snapperRollbackFolderName}" "${snapperSnapshotsSubvolName}" "${snapperRollbackConfig}"

            # # --- Zugriffs- und Besitzrechte
            # echo -e "\n*** Zugriffs- und Besitzrechte für '${snapperSnapshotFolder}' werden festgelegt..."
            # sudo chown -R :wheel "${snapperSnapshotFolder}" && sudo chmod -R 750 "${snapperSnapshotFolder}"
            # echo -e "\n*** Zugriffs- und Besitzrechte für '/${snapperRollbackFolderName}' werden festgelegt..."
            # sudo chown -R :wheel "/${snapperRollbackFolderName}" && sudo chmod -R 750 "/${snapperRollbackFolderName}"

            # --- Services
            # UEFI oder BIOS + GRUB # systemd boot: kein Eintrag, 'snapper-rollback' oder manueller Sprung in tty, um auf best. snapshot zurückzusetzen
            # if [ -e "${efiDir}/grub.cfg" ] || [ -e "/boot/grub" ]; then    # Grub
            if [ -e "/boot/grub" ]; then # Grub
                echo -e "\n*** Enable 'grub-btrfsd.service'..."
                sudo systemctl enable --now grub-btrfsd.service
            fi

            echo -e "\n*** Enable 'snapper-cleanup.timer'..."
            sudo systemctl enable --now snapper-cleanup.timer

            # --- pacman hooks
            # https://wiki.archlinux.org/title/Pacman#Hooks
            # https://wiki.archlinux.org/title/System_backup#Snapshots_and_/boot_partition
            # https://wiki.archlinux.org/title/Talk:System_backup#Snapshots_and_/boot_partition_hook_is_broken
            # TOOD: verify:
            # - zieht nur für bereits installierte kernel; für nachträglich installierte kernels werden die hooks erst bei nächstem kernel update gesatartet
            # - -> installation lts kernel vor snapper config hinzugefügt

            if grep -i '^#HookDir' /etc/pacman.conf; then
                echo -e "\n*** Aktiviere zusätzliches hook directory '/etc/pacman.d/hooks/' in '/etc/pacman.conf'."
                sudo sed -i 's|^#HookDir|HookDir|g' /etc/pacman.conf
            else
                echo -e "\n*** Zusätzliches hook directory '/etc/pacman.d/hooks/' in '/etc/pacman.conf' bereits aktiviert."
            fi

            echo -e "\n*** Erstelle Pacman Hook für Backup von '/boot' bzw. '${efiDir}'"
            echo "Installiere rsync, falls nicht vorhanden..."
            sudo pacman -S --needed --noconfirm rsync

            copysuccess="false"
            if [ -d "/boot" ]; then
                # für UEFI + systemd-boot eigentlich nicht notwendig, da /boot nicht auf eigener Partition ist und somit in snapshots drin

                echo "Erstelle Hook-Dateien in '/etc/pacman.d/hooks/' für '/boot/'..."
                sudo mkdir -pv /etc/pacman.d/hooks &&

                # Ermittlung SCRIPT_DIR funktioniert nicht zuverlässig
                # SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd) # absolute path # https://codefather.tech/blog/bash-get-script-directory/
                # SCRIPT_DIR=$(dirname "${BASH_SOURCE[0]}")
                # echo "SCRIPT_DIR: ${SCRIPT_DIR}"

                # sudo cp -fv "${SCRIPT_DIR}/files/55-bootbackup_pre.hook" /etc/pacman.d/hooks/55-bootbackup_pre.hook
                sudo cp -fv "${HOME}/ansible_workstation/files/55-bootbackup_pre.hook" /etc/pacman.d/hooks/55-bootbackup_pre.hook
                # sudo cp -fv "${SCRIPT_DIR}/files/95-bootbackup_post.hook" /etc/pacman.d/hooks/95-bootbackup_post.hook
                sudo cp -fv "${HOME}/ansible_workstation/files/95-bootbackup_post.hook" /etc/pacman.d/hooks/95-bootbackup_post.hook

                sudo chown root:root /etc/pacman.d/hooks/55-bootbackup_pre.hook
                sudo chown root:root /etc/pacman.d/hooks/95-bootbackup_post.hook

                echo "Erstelle backup folder '/.bootbackup' für boot backup..."
                sudo mkdir -pv /.bootbackup/pre
                sudo mkdir -pv /.bootbackup/post

                echo "Erstelle initiales Backup von '/boot' nach '/.bootbackup'..." # somit in zukünftigen snapshots von '/' enthalten
                sudo rsync -av --mkpath --delete /boot/ /.bootbackup/pre/
                sudo rsync -av --mkpath --delete /boot/ /.bootbackup/post/

                # Check
                if [ ! -e /etc/pacman.d/hooks/55-bootbackup_pre.hook ] || [ ! -e /etc/pacman.d/hooks/95-bootbackup_post.hook ]; then
                    echo -e "\e[0;31mFehler beim kopieren der '/etc/pacman.d/hooks/' für '/boot/'\nSkript wird beendet.\e[0m"
                    exit 1
                fi

            fi

            if [ "$(sudo ls /efi)" ]; then # if [ -d "/efi" ]; then
                echo "Erstelle Hook-Dateien in '/etc/pacman.d/hooks/' für '/efi/'..."
                    sudo mkdir -pv /etc/pacman.d/hooks

                # Ermittlung SCRIPT_DIR funktioniert nicht zuverlässig
                # SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd) # absolute path # https://codefather.tech/blog/bash-get-script-directory/
                # SCRIPT_DIR=$(dirname "${BASH_SOURCE[0]}") # relative path
                # echo "SCRIPT_DIR: ${SCRIPT_DIR}

                # sudo cp -fv "${SCRIPT_DIR}/files/55-efibackup_pre.hook" /etc/pacman.d/hooks/55-efibackup_pre.hook
                sudo cp -fv "${HOME}/ansible_workstation/files/55-efibackup_pre.hook" /etc/pacman.d/hooks/55-efibackup_pre.hook
                # sudo cp -fv "${SCRIPT_DIR}/files/95-efibackup_post.hook" /etc/pacman.d/hooks/95-efibackup_post.hook
                sudo cp -fv "${HOME}/ansible_workstation/files/95-efibackup_post.hook" /etc/pacman.d/hooks/95-efibackup_post.hook

                sudo chown root:root /etc/pacman.d/hooks/55-efibackup_pre.hook
                sudo chown root:root /etc/pacman.d/hooks/95-efibackup_post.hook

                echo "Erstelle backup folder '/.efibackup' für efi backup..."
                sudo mkdir -pv /.efibackup/pre
                sudo mkdir -pv /.efibackup/post

                echo "Erstelle initiales Backup von '/efi' nach '/.efibackup'..." # somit in zukünftigen snapshots von '/' enthalten
                sudo rsync -av --mkpath --delete /efi/ /.efibackup/pre/
                sudo rsync -av --mkpath --delete /efi/ /.efibackup/post/

                if [ ! -e /etc/pacman.d/hooks/55-efibackup_pre.hook ] || [ ! -e /etc/pacman.d/hooks/95-efibackup_post.hook ]; then
                    echo -e "\e[0;31mFehler beim kopieren der '/etc/pacman.d/hooks/' für '/efi/'\nSkript wird beendet.\e[0m"
                    exit 1
                fi
            fi

            # --- initial snapshot
            echo -e "\n*** Erstelle initial snapshot (single): '***Base System Install***'"
            sudo snapper -c "${snapperConfigName_root}" create -d "***Base System Install***"
            echo "Aktuelle Liste der Snapshots:"
            sudo snapper ls

            # --- update bootloader config
            if [ -e "${efiDir}/grub.cfg" ] || [ -e "/boot/grub" ]; then   # GRUB # e.g.: "/boot/efi/grub.cfg"
                echo -e "\n*** Aktualisiere Grub (grub.cfg)"
                sudo grub-mkconfig -o /boot/grub/grub.cfg
                echo "(Re)Generiere Snapshots-(Sub)Menüeinträge in grub"
                sudo grub-mkconfig
            fi

            # systemd-boot: kein Booteintrag für Snapshots # nutze: 'snapper list' + 'snapper-rollback'
            ;;

        *)
            echo -e "\e[0;33mFür verwendetes OS '${os}' wurde Installation/Konfiguration von 'snapper' noch nicht getestet."
            echo -e "Manuelle Durchführung notwendig\e[0m"
            touch "${HOME}/.ansible_installScript_snapper_NOT-DONE"
            read -r -p "Eingabe-Taste drücken um fortzufahren"
            exit 0
            ;;
    esac

    touch "${HOME}/.ansible_installScript_snapper" # wird auch bei default-switch - Zweig erstellt, d.h. snapper nicht konfiguriert (-> Manuelle Durchführung notwendig)

    echo -e "\e[0;33m*** Ende Snapper-Teil\e[0m"
    echo -e "\e[0;33m*** ********************************************\e[0m"
}

config-snapperRollback() { # called in a separate script after reboot
    # Parameter 1: path to snapperRollbackFolder (e.g. '/.btrfsroot')
    # Parameter 2: snapper snapshot subvolume (e.g. '@snapshots')
    # Parameter 3: snapperRollbackConfig file (e.g. '/etc/snapper-rollback.conf')

    local srf="${1}" # path to snapperRollbackFolder
    local sss="${2}" # snapper snapshot subvolume
    local srcf="${3}" # snapperRollbackConfig file

    echo "Download and install snapper-rollback (AUR)..."
    if [[ $(command -v snapper-rollback) ]]; then
        echo -e "\e[0;33m- 'snapper-rollback' is already installed \e[0m"
    else
        # echo "(Initial-)Password '${initialPassword}' can be used if asked"
        # su - USERID -c "curl -L -O https://aur.archlinux.org/cgit/aur.git/snapshot/snapper-rollback.tar.gz" # user not yet available in chroot
        curl -L -O https://aur.archlinux.org/cgit/aur.git/snapshot/snapper-rollback.tar.gz
        tar -xf snapper-rollback.tar.gz
        cd snapper-rollback || return
        makepkg --noconfirm --needed -sic
        cd .. || return
        rm -rf snapper-rollback snapper-rollback.tar.gz
    fi

    echo -e "Modify snapperRollbackConfig: set snapper snapshots subvolume name to configured subvolume name '${sss}'..."
    # currently set in config: @snapshots # which we used in the config (if not changed manually), so ther should be no change necessary
    sudo sed -i "s|@snapshots|${sss}|g" "${srcf}"

    echo -e "Modify snapperRollbackConfig: set configured snapperRollbackFolder to configured path '${srf}'..."
    # currently set in config: mountpoint = /btrfsroot
    sudo sed -i "s|/btrfsroot|${srf}|g" "${srcf}" # changing '/btrfsroot' to configured snapperRollbackFolder

    # --- helper script for snapper rollback, which also copies corresponding kernel + initramfs from backups to /efi and/or /boot
    # an alias will be created in shellconf file via ansible task which calls this script
    echo -e "Copy 'helper script' (rollback_eos.sh) to  '/usr/local/bin'..."
    sudo rsync files/rollback_eos.sh /usr/local/bin/rollback_eos.sh
}

config-updatedb() {
    ### ---
    ### updatedb.conf anpassen: keine Indexierung des (Snapper) snapshotFolder
    ### ---
    ### * https://wiki.archlinux.org/title/Snapper#Preventing_slowdowns
    ### * https://unix.stackexchange.com/questions/566495/how-can-i-change-the-configuration-of-etc-updatedb-conf-file
    ### * https://serverfault.com/questions/454051/how-can-i-view-updatedb-database-content-and-then-exclude-certain-files-paths
    ###   * https://serverfault.com/a/565094

    if ! grep -q "${snapshotFolder}" "${updbconf}" && grep -q "${pngrep}" "${updbconf}"; then
        # wenn .snapshots noch nicht in conf oder PRUNENAMES nicht in conf

        prunenamesOld=$(grep "${pngrep}" "${updbconf}" | sed 's/.$//') # aktuelle Werte bei PRUNENAMES, ohne letztes Zeichen ('"')
        echo "prunenames alt: ${prunenamesOld}\""
        prunenamesNew="${prunenamesOld} ${snapshotFolder}\""
        echo "prunenames neu: ${prunenamesNew}"

        sudo sed -i "s/${prunenamesOld}\"/${prunenamesNew}/" "${updbconf}"
        # sudo updatedb --add-prunenames "${snapshotFolder}"    # sudo updatedb --prunenames NAMES
        # sudo updatedb --debug-pruning > ~/updatedb_debug.log 2>&1 &
        sudo updatedb --debug-pruning 2>&1 | tee ~/updatedb_debug.log 1>/dev/null
    else
        echo "Eintrag '${snapshotFolder}' bereits in '${updbconf}' vorhanden oder '${pngrep}' nicht vorhanden"
    fi
}

config-mirrorlist() {
    # ### Repo Mirrors / reflector
    # https://wiki.archlinux.org/title/Mirrors#top-page
    # https://wiki.archlinux.org/title/Reflector#top-page
    # https://man.archlinux.org/man/reflector.1#EXAMPLES
    # pacman conf: /etc/pacman.conf
    # reflector conf: /etc/xdg/reflector/reflector.conf

    echo -e "Retrieve up-to-date Arch Linux mirror data, rank it and update all packages on the system..."
    sudo pacman -Sy && sudo pacman -S --needed --noconfirm reflector # ensure 'reflector' is installed

    if [[ "${os}" = "EndeavourOS"* ]]; then
        echo -e "\nRetrieve up-to-date endeavouros mirror data and rank it..."
        # Backup current endeavouros mirrorlists:
        sudo cp /etc/pacman.d/endeavouros-mirrorlist /etc/pacman.d/endeavouros-mirrorlist.backup
        # rankmirrors für EndeavourOS (config: /etc/eos-rankmirrors.conf):
        sudo eos-rankmirrors # --verbose
    fi

    # Backup current mirrorlists:
    sudo cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup

    # Retrieve the latest mirror list from the Arch Linux Mirror Status page + listed countries:
    echo "reflector - aktualisiere archlinux mirrors..."
    sudo reflector --verbose --age 12 --protocol https --sort rate --country 'Germany,France,Austria,Switzerland' --save /etc/pacman.d/mirrorlist
    sudo systemctl enable --now reflector.service

    # Update all packages on the system:
    sudo pacman -Syyu --noconfirm
}

install-initialSw-Arch() {
    echo -e "Installation initial benoetigte Software for Arch-bases systems (curl git openssh rsync vim)"
    sudo pacman -S --needed --noconfirm ansible curl git openssh rsync vim # python-pipx # ansible-core firewalld

    echo -e "\nInstallation benoetigte Softwarepackages zur Installation von AUR helpers, AUR-Packages..."
    sudo pacman -S --needed --noconfirm base-devel

    # ### VM guest - spice-vdagent
    echo -e "\n Installation (wenn VM) spice agent for Linux guests (z.B. für clipboard sharing zwischen host+guest)"
    [[ $(systemd-detect-virt) != *"none"* ]] && sudo pacman -S --needed --noconfirm spice-vdagent

    # ### VM Qemu/KVM: uninstall iptables, install iptables-nft
    echo -e "\nVM - Qemu/KVM: Wiki empfiehlt inst. von 'iptables-nft'"
    echo -e "Bestätige, dass 'iptables' (und 'inxi') gelöscht und 'iptables-nft' installiert wird"
    echo -e "Anmerkung: 'inxi' wird im Rahmen basis-inst wieder installiert"
    sudo pacman -S --needed --noconfirm iptables-nft
}

install-aur-helper() {
    echo -e "\nInstalling 'paru' - AUR helper..." # paru needed e.g. in "install-furtherSw-Arch()"
    if ! [ -x "$(command -v paru)" ]; then
        sudo git clone https://aur.archlinux.org/paru.git /tmp/paru
        sudo chown -R "${userid}":users /tmp/paru
        cd /tmp/paru && makepkg -sic --needed
        cd || return
        sudo rm -rf /tmp/paru # cleanup
    else
        echo -e "'paru' is already installed."
    fi
}

install-furtherSw-Arch() {
    install-aur-helper # e.g. paru

    echo -e "\nInstall some Gnome Extensions (gsconnect) from AUR ..."
    paru -S --needed --skipreview gnome-shell-extension-gsconnect

    echo -e "\nInstall various required software packages (bashdb, gtkhash, units) from AUR..."
    paru -S --needed --skipreview bashdb gtkhash units

    echo -e "\nInstall linux steam integration from AUR..."
    paru -S --needed --skipreview linux-steam-integration

    echo -e "\nInstall ulauncher from AUR..."
    paru -S --needed --skipreview ulauncher
    echo -e "\nStart + enable ulauncher.service for '${userid}'..."
    systemctl --user enable --now ulauncher.service # su -u "${userid}" -c "systemctl --user enable --now ulauncher.service"

    # lsblkBtrfs=$(lsblk -P -o +FSTYPE | grep "btrfs")   # $(blkid | grep btrfs) # $(mount | grep "^/dev" | grep btrfs)  # $(grep btrfs /etc/fstab)
    # if [ -n "${lsblkBtrfs}" ]; then
    if [[ $(stat -f -c %T /) = 'btrfs' ]]; then
        echo -e "\nInstall 'btrfs-assistant' from AUR..."
        paru -S --needed --skipreview btrfs-assistant # && touch "${HOME}/.ansible_installScript_AUR-btrfsassistantInstalled"
    fi

    echo -e "\nInstall Citrix Workspace App (icaclient) from AUR..."
    paru -S --needed --skipreview icaclient && touch "${HOME}/.ansible_installScript_AUR-icaclientInstalled"
    # sudo pacman -S --needed --noconfirm icaclient
    mkdir -p "${HOME}/.ICAClient/cache" && \
    sudo rsync -aPhEv /opt/Citrix/ICAClient/config/{All_Regions,Trusted_Region,Unknown_Region,canonicalization,regions}.ini "${HOME}/.ICAClient/"

    echo -e "\nInstall 'visual-studio-code-bin' from AUR..." # instead of flatpak
    paru -S --needed --skipreview visual-studio-code-bin
    # sudo pacman -S --needed --noconfirm visual-studio-code-bin

    echo -e "\nInstall Powershell AUR..."
    paru -S --needed --skipreview powershell-bin
    # sudo pacman -S --needed --noconfirm powershell-bin

    echo -e "\nInstall espanso (wayland) from AUR (will takes some time)..."
    paru -S --needed --skipreview espanso-wayland   # espanso-gui

    # echo -e "\nInstall several Applications (Vorta) from AUR..."
    # paru -S --needed --skipreview vorta joplin-desktop # -> change: flatpak

    # echo -e "\nInstall Brave Browser from AUR..."
    # paru -S --needed --skipreview brave-bin # -> change: flatpak

    # echo -e "\nInstall Microsoft TTF Fonts from AUR..." # takes quite some time
    # paru -S --needed --skipreview ttf-ms-fonts && touch "${HOME}/.ansible_installScript_AUR-ttfmsfontsInstalled"

    # --- 'autokey' auskommentiert, da nicht mit Wayland funktioniert --- #
    # echo -e "\nInstall 'autokey-gtk' from AUR..."         # da aktuell Gnome verwende
    # paru -S --needed --skipreview autokey-gtk && touch "${HOME}/.ansible_installScript_autokeyGtkInstalled"
    # echo -e "\nInstall 'autokey-qt' from AUR (Arch)"      # e.g. when using Plasma
    # paru -S --needed --skipreview autokey-qt # && touch "${HOME}/.ansible_installScript_autokeyQtInstalled"

    # echo -e "\nInstall woeusb-ng (Tool to create Windows boot stick) from AUR..."
    # paru -S --needed --skipreview woeusb-ng && touch "${HOME}/.ansible_installScript_AUR-woeusbngInstalled"

    # echo -e "\nVM - Download 'virtio-win' image from AUR..."
    # paru -S --needed --skipreview virtio-win && touch "${HOME}/.ansible_installScript_AUR-vmVirtioWinInstalled"

    # echo -e "\nCreating flag-file '.ansible_installScript_severalAurPkgInstalled'..."
    # touch "${HOME}/.ansible_installScript_severalAurPkgInstalled"
}

install-initialSw-Debian() {
    # ### Update / Upgrade + Installs
    echo -e "\nUpdate Repos, upgrade and autoremove"
    sudo apt-get update && sudo apt-get upgrade -y
    sudo apt-get autoremove -y

    echo -e "\nInstallation benoetigte Software - ansible"
    sudo apt-get install -y ansible # ansible-core

    echo -e "\nInstallation benoetigte Software (git, rsync, vim, ..."
    sudo apt-get install -y git rsync ssh vim # pipx, ufw
    # bereits installiert: chrome-gnome-shell curl openssh-client openssh-server

    echo -e "\nInstalliere benötigte Packages für Installation von Microsoft PowerShell"
    sudo apt-get install -y apt-transport-https software-properties-common wget

    echo -e "\nInstalliere noch fehlende, benötigte Packages für Installation von Brave Web Browser"
    sudo apt-get install -y curl

    echo -e "\nInstallation (wenn VM) spice agent for Linux guests (z.B. für clipboard sharing host+guest)"
    [[ $(systemd-detect-virt) != *"none"* ]] && sudo apt-get install -y spice-vdagent
}

add-repo-Debian() {
    # ### Ulauncher
    # - https://ulauncher.io/#Download
    sudo apt install -y gnupg
    gpg --keyserver keyserver.ubuntu.com --recv 0xfaf1020699503176
    gpg --export 0xfaf1020699503176 | sudo tee /usr/share/keyrings/ulauncher-archive-keyring.gpg >/dev/null
    echo "deb [signed-by=/usr/share/keyrings/ulauncher-archive-keyring.gpg] \
        http://ppa.launchpad.net/agornostal/ulauncher/ubuntu jammy main" | sudo tee /etc/apt/sources.list.d/ulauncher-jammy.list
    # sudo apt update && sudo apt install -y ulauncher # installation in "packages_workstation-Gnome.yml"
}
